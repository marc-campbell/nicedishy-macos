// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spacex/api/device/dish.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "spacex/api/device/Dish.pbobjc.h"
#import "spacex/api/device/Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(ChallengeResponse);
GPBObjCClassDeclaration(DeviceInfo);
GPBObjCClassDeclaration(DeviceState);
GPBObjCClassDeclaration(DishAlerts);
GPBObjCClassDeclaration(DishObstructionStats);
GPBObjCClassDeclaration(DishOutage);

#pragma mark - DishRoot

@implementation DishRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - DishRoot_FileDescriptor

static GPBFileDescriptor *DishRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"SpaceX.API.Device"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum DishState

GPBEnumDescriptor *DishState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Connected\000Searching\000Booting\000";
    static const int32_t values[] = {
        DishState_Unknown,
        DishState_Connected,
        DishState_Searching,
        DishState_Booting,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DishState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DishState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DishState_IsValidValue(int32_t value__) {
  switch (value__) {
    case DishState_Unknown:
    case DishState_Connected:
    case DishState_Searching:
    case DishState_Booting:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DishStowRequest

@implementation DishStowRequest

@dynamic unstow;

typedef struct DishStowRequest__storage_ {
  uint32_t _has_storage_[1];
} DishStowRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unstow",
        .dataTypeSpecific.clazz = Nil,
        .number = DishStowRequest_FieldNumber_Unstow,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DishStowRequest class]
                                     rootClass:[DishRoot class]
                                          file:DishRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DishStowRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DishStowResponse

@implementation DishStowResponse


typedef struct DishStowResponse__storage_ {
  uint32_t _has_storage_[1];
} DishStowResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DishStowResponse class]
                                     rootClass:[DishRoot class]
                                          file:DishRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DishStowResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DishGetContextRequest

@implementation DishGetContextRequest


typedef struct DishGetContextRequest__storage_ {
  uint32_t _has_storage_[1];
} DishGetContextRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DishGetContextRequest class]
                                     rootClass:[DishRoot class]
                                          file:DishRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DishGetContextRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DishGetContextResponse

@implementation DishGetContextResponse

@dynamic hasDeviceInfo, deviceInfo;
@dynamic hasDeviceState, deviceState;
@dynamic obstructionFraction;
@dynamic obstructionValidS;
@dynamic cellId;
@dynamic popRackId;
@dynamic initialSatelliteId;
@dynamic initialGatewayId;
@dynamic onBackupBeam;
@dynamic secondsToSlotEnd;
@dynamic debugTelemetryEnabled;

typedef struct DishGetContextResponse__storage_ {
  uint32_t _has_storage_[1];
  float obstructionFraction;
  float obstructionValidS;
  uint32_t cellId;
  uint32_t popRackId;
  float secondsToSlotEnd;
  uint32_t initialSatelliteId;
  uint32_t initialGatewayId;
  DeviceInfo *deviceInfo;
  DeviceState *deviceState;
} DishGetContextResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(DeviceInfo),
        .number = DishGetContextResponse_FieldNumber_DeviceInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DishGetContextResponse__storage_, deviceInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "obstructionFraction",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetContextResponse_FieldNumber_ObstructionFraction,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DishGetContextResponse__storage_, obstructionFraction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "obstructionValidS",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetContextResponse_FieldNumber_ObstructionValidS,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DishGetContextResponse__storage_, obstructionValidS),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "cellId",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetContextResponse_FieldNumber_CellId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DishGetContextResponse__storage_, cellId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "popRackId",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetContextResponse_FieldNumber_PopRackId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DishGetContextResponse__storage_, popRackId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "secondsToSlotEnd",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetContextResponse_FieldNumber_SecondsToSlotEnd,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DishGetContextResponse__storage_, secondsToSlotEnd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "deviceState",
        .dataTypeSpecific.clazz = GPBObjCClass(DeviceState),
        .number = DishGetContextResponse_FieldNumber_DeviceState,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DishGetContextResponse__storage_, deviceState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "initialSatelliteId",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetContextResponse_FieldNumber_InitialSatelliteId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DishGetContextResponse__storage_, initialSatelliteId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "initialGatewayId",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetContextResponse_FieldNumber_InitialGatewayId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DishGetContextResponse__storage_, initialGatewayId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "onBackupBeam",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetContextResponse_FieldNumber_OnBackupBeam,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "debugTelemetryEnabled",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetContextResponse_FieldNumber_DebugTelemetryEnabled,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DishGetContextResponse class]
                                     rootClass:[DishRoot class]
                                          file:DishRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DishGetContextResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DishOutage

@implementation DishOutage

@dynamic cause;
@dynamic startTimestampNs;
@dynamic durationNs;
@dynamic didSwitch;

typedef struct DishOutage__storage_ {
  uint32_t _has_storage_[1];
  DishOutage_Cause cause;
  int64_t startTimestampNs;
  uint64_t durationNs;
} DishOutage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cause",
        .dataTypeSpecific.enumDescFunc = DishOutage_Cause_EnumDescriptor,
        .number = DishOutage_FieldNumber_Cause,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DishOutage__storage_, cause),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "startTimestampNs",
        .dataTypeSpecific.clazz = Nil,
        .number = DishOutage_FieldNumber_StartTimestampNs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DishOutage__storage_, startTimestampNs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "durationNs",
        .dataTypeSpecific.clazz = Nil,
        .number = DishOutage_FieldNumber_DurationNs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DishOutage__storage_, durationNs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "didSwitch",
        .dataTypeSpecific.clazz = Nil,
        .number = DishOutage_FieldNumber_DidSwitch,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DishOutage class]
                                     rootClass:[DishRoot class]
                                          file:DishRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DishOutage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DishOutage_Cause_RawValue(DishOutage *message) {
  GPBDescriptor *descriptor = [DishOutage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DishOutage_FieldNumber_Cause];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDishOutage_Cause_RawValue(DishOutage *message, int32_t value) {
  GPBDescriptor *descriptor = [DishOutage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DishOutage_FieldNumber_Cause];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum DishOutage_Cause

GPBEnumDescriptor *DishOutage_Cause_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Booting\000Stowed\000ThermalShutdown\000N"
        "oSchedule\000NoSats\000Obstructed\000NoDownlink\000N"
        "oPings\000";
    static const int32_t values[] = {
        DishOutage_Cause_Unknown,
        DishOutage_Cause_Booting,
        DishOutage_Cause_Stowed,
        DishOutage_Cause_ThermalShutdown,
        DishOutage_Cause_NoSchedule,
        DishOutage_Cause_NoSats,
        DishOutage_Cause_Obstructed,
        DishOutage_Cause_NoDownlink,
        DishOutage_Cause_NoPings,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DishOutage_Cause)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DishOutage_Cause_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DishOutage_Cause_IsValidValue(int32_t value__) {
  switch (value__) {
    case DishOutage_Cause_Unknown:
    case DishOutage_Cause_Booting:
    case DishOutage_Cause_Stowed:
    case DishOutage_Cause_ThermalShutdown:
    case DishOutage_Cause_NoSchedule:
    case DishOutage_Cause_NoSats:
    case DishOutage_Cause_Obstructed:
    case DishOutage_Cause_NoDownlink:
    case DishOutage_Cause_NoPings:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DishGetHistoryResponse

@implementation DishGetHistoryResponse

@dynamic current;
@dynamic popPingDropRateArray, popPingDropRateArray_Count;
@dynamic popPingLatencyMsArray, popPingLatencyMsArray_Count;
@dynamic downlinkThroughputBpsArray, downlinkThroughputBpsArray_Count;
@dynamic uplinkThroughputBpsArray, uplinkThroughputBpsArray_Count;
@dynamic outagesArray, outagesArray_Count;

typedef struct DishGetHistoryResponse__storage_ {
  uint32_t _has_storage_[1];
  GPBFloatArray *popPingDropRateArray;
  GPBFloatArray *popPingLatencyMsArray;
  GPBFloatArray *downlinkThroughputBpsArray;
  GPBFloatArray *uplinkThroughputBpsArray;
  NSMutableArray *outagesArray;
  uint64_t current;
} DishGetHistoryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "current",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetHistoryResponse_FieldNumber_Current,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DishGetHistoryResponse__storage_, current),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "popPingDropRateArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetHistoryResponse_FieldNumber_PopPingDropRateArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DishGetHistoryResponse__storage_, popPingDropRateArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "popPingLatencyMsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetHistoryResponse_FieldNumber_PopPingLatencyMsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DishGetHistoryResponse__storage_, popPingLatencyMsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "downlinkThroughputBpsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetHistoryResponse_FieldNumber_DownlinkThroughputBpsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DishGetHistoryResponse__storage_, downlinkThroughputBpsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "uplinkThroughputBpsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetHistoryResponse_FieldNumber_UplinkThroughputBpsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DishGetHistoryResponse__storage_, uplinkThroughputBpsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "outagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DishOutage),
        .number = DishGetHistoryResponse_FieldNumber_OutagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DishGetHistoryResponse__storage_, outagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DishGetHistoryResponse class]
                                     rootClass:[DishRoot class]
                                          file:DishRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DishGetHistoryResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DishGetStatusResponse

@implementation DishGetStatusResponse

@dynamic hasDeviceInfo, deviceInfo;
@dynamic hasDeviceState, deviceState;
@dynamic hasAlerts, alerts;
@dynamic hasOutage, outage;
@dynamic secondsToFirstNonemptySlot;
@dynamic popPingDropRate;
@dynamic downlinkThroughputBps;
@dynamic uplinkThroughputBps;
@dynamic popPingLatencyMs;
@dynamic hasObstructionStats, obstructionStats;
@dynamic stowRequested;
@dynamic boresightAzimuthDeg;
@dynamic boresightElevationDeg;

typedef struct DishGetStatusResponse__storage_ {
  uint32_t _has_storage_[1];
  float secondsToFirstNonemptySlot;
  float popPingDropRate;
  float downlinkThroughputBps;
  float uplinkThroughputBps;
  float popPingLatencyMs;
  float boresightAzimuthDeg;
  float boresightElevationDeg;
  DeviceInfo *deviceInfo;
  DeviceState *deviceState;
  DishObstructionStats *obstructionStats;
  DishAlerts *alerts;
  DishOutage *outage;
} DishGetStatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(DeviceInfo),
        .number = DishGetStatusResponse_FieldNumber_DeviceInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DishGetStatusResponse__storage_, deviceInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deviceState",
        .dataTypeSpecific.clazz = GPBObjCClass(DeviceState),
        .number = DishGetStatusResponse_FieldNumber_DeviceState,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DishGetStatusResponse__storage_, deviceState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "secondsToFirstNonemptySlot",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetStatusResponse_FieldNumber_SecondsToFirstNonemptySlot,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DishGetStatusResponse__storage_, secondsToFirstNonemptySlot),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "popPingDropRate",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetStatusResponse_FieldNumber_PopPingDropRate,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DishGetStatusResponse__storage_, popPingDropRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "obstructionStats",
        .dataTypeSpecific.clazz = GPBObjCClass(DishObstructionStats),
        .number = DishGetStatusResponse_FieldNumber_ObstructionStats,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DishGetStatusResponse__storage_, obstructionStats),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "alerts",
        .dataTypeSpecific.clazz = GPBObjCClass(DishAlerts),
        .number = DishGetStatusResponse_FieldNumber_Alerts,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DishGetStatusResponse__storage_, alerts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "downlinkThroughputBps",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetStatusResponse_FieldNumber_DownlinkThroughputBps,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DishGetStatusResponse__storage_, downlinkThroughputBps),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "uplinkThroughputBps",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetStatusResponse_FieldNumber_UplinkThroughputBps,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DishGetStatusResponse__storage_, uplinkThroughputBps),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "popPingLatencyMs",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetStatusResponse_FieldNumber_PopPingLatencyMs,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DishGetStatusResponse__storage_, popPingLatencyMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "stowRequested",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetStatusResponse_FieldNumber_StowRequested,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "boresightAzimuthDeg",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetStatusResponse_FieldNumber_BoresightAzimuthDeg,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(DishGetStatusResponse__storage_, boresightAzimuthDeg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "boresightElevationDeg",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetStatusResponse_FieldNumber_BoresightElevationDeg,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(DishGetStatusResponse__storage_, boresightElevationDeg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "outage",
        .dataTypeSpecific.clazz = GPBObjCClass(DishOutage),
        .number = DishGetStatusResponse_FieldNumber_Outage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DishGetStatusResponse__storage_, outage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DishGetStatusResponse class]
                                     rootClass:[DishRoot class]
                                          file:DishRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DishGetStatusResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DishGetObstructionMapRequest

@implementation DishGetObstructionMapRequest


typedef struct DishGetObstructionMapRequest__storage_ {
  uint32_t _has_storage_[1];
} DishGetObstructionMapRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DishGetObstructionMapRequest class]
                                     rootClass:[DishRoot class]
                                          file:DishRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DishGetObstructionMapRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DishGetObstructionMapResponse

@implementation DishGetObstructionMapResponse

@dynamic numRows;
@dynamic numCols;
@dynamic snrArray, snrArray_Count;

typedef struct DishGetObstructionMapResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t numRows;
  uint32_t numCols;
  GPBFloatArray *snrArray;
} DishGetObstructionMapResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "numRows",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetObstructionMapResponse_FieldNumber_NumRows,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DishGetObstructionMapResponse__storage_, numRows),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numCols",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetObstructionMapResponse_FieldNumber_NumCols,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DishGetObstructionMapResponse__storage_, numCols),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "snrArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DishGetObstructionMapResponse_FieldNumber_SnrArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DishGetObstructionMapResponse__storage_, snrArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DishGetObstructionMapResponse class]
                                     rootClass:[DishRoot class]
                                          file:DishRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DishGetObstructionMapResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DishAlerts

@implementation DishAlerts

@dynamic motorsStuck;
@dynamic thermalThrottle;
@dynamic thermalShutdown;
@dynamic mastNotNearVertical;
@dynamic unexpectedLocation;
@dynamic slowEthernetSpeeds;

typedef struct DishAlerts__storage_ {
  uint32_t _has_storage_[1];
} DishAlerts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "motorsStuck",
        .dataTypeSpecific.clazz = Nil,
        .number = DishAlerts_FieldNumber_MotorsStuck,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "thermalShutdown",
        .dataTypeSpecific.clazz = Nil,
        .number = DishAlerts_FieldNumber_ThermalShutdown,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "thermalThrottle",
        .dataTypeSpecific.clazz = Nil,
        .number = DishAlerts_FieldNumber_ThermalThrottle,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "unexpectedLocation",
        .dataTypeSpecific.clazz = Nil,
        .number = DishAlerts_FieldNumber_UnexpectedLocation,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "mastNotNearVertical",
        .dataTypeSpecific.clazz = Nil,
        .number = DishAlerts_FieldNumber_MastNotNearVertical,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "slowEthernetSpeeds",
        .dataTypeSpecific.clazz = Nil,
        .number = DishAlerts_FieldNumber_SlowEthernetSpeeds,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DishAlerts class]
                                     rootClass:[DishRoot class]
                                          file:DishRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DishAlerts__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DishObstructionStats

@implementation DishObstructionStats

@dynamic currentlyObstructed;
@dynamic fractionObstructed;
@dynamic validS;
@dynamic wedgeFractionObstructedArray, wedgeFractionObstructedArray_Count;
@dynamic wedgeAbsFractionObstructedArray, wedgeAbsFractionObstructedArray_Count;
@dynamic avgProlongedObstructionDurationS;
@dynamic avgProlongedObstructionIntervalS;
@dynamic avgProlongedObstructionValid;

typedef struct DishObstructionStats__storage_ {
  uint32_t _has_storage_[1];
  float fractionObstructed;
  float validS;
  float avgProlongedObstructionDurationS;
  float avgProlongedObstructionIntervalS;
  GPBFloatArray *wedgeFractionObstructedArray;
  GPBFloatArray *wedgeAbsFractionObstructedArray;
} DishObstructionStats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fractionObstructed",
        .dataTypeSpecific.clazz = Nil,
        .number = DishObstructionStats_FieldNumber_FractionObstructed,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DishObstructionStats__storage_, fractionObstructed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "wedgeFractionObstructedArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DishObstructionStats_FieldNumber_WedgeFractionObstructedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DishObstructionStats__storage_, wedgeFractionObstructedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "wedgeAbsFractionObstructedArray",
        .dataTypeSpecific.clazz = Nil,
        .number = DishObstructionStats_FieldNumber_WedgeAbsFractionObstructedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DishObstructionStats__storage_, wedgeAbsFractionObstructedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "validS",
        .dataTypeSpecific.clazz = Nil,
        .number = DishObstructionStats_FieldNumber_ValidS,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DishObstructionStats__storage_, validS),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "currentlyObstructed",
        .dataTypeSpecific.clazz = Nil,
        .number = DishObstructionStats_FieldNumber_CurrentlyObstructed,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "avgProlongedObstructionDurationS",
        .dataTypeSpecific.clazz = Nil,
        .number = DishObstructionStats_FieldNumber_AvgProlongedObstructionDurationS,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DishObstructionStats__storage_, avgProlongedObstructionDurationS),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "avgProlongedObstructionIntervalS",
        .dataTypeSpecific.clazz = Nil,
        .number = DishObstructionStats_FieldNumber_AvgProlongedObstructionIntervalS,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DishObstructionStats__storage_, avgProlongedObstructionIntervalS),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "avgProlongedObstructionValid",
        .dataTypeSpecific.clazz = Nil,
        .number = DishObstructionStats_FieldNumber_AvgProlongedObstructionValid,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DishObstructionStats class]
                                     rootClass:[DishRoot class]
                                          file:DishRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DishObstructionStats__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DishAuthenticateResponse

@implementation DishAuthenticateResponse

@dynamic hasDish, dish;

typedef struct DishAuthenticateResponse__storage_ {
  uint32_t _has_storage_[1];
  ChallengeResponse *dish;
} DishAuthenticateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dish",
        .dataTypeSpecific.clazz = GPBObjCClass(ChallengeResponse),
        .number = DishAuthenticateResponse_FieldNumber_Dish,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DishAuthenticateResponse__storage_, dish),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DishAuthenticateResponse class]
                                     rootClass:[DishRoot class]
                                          file:DishRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DishAuthenticateResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
