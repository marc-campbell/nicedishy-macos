// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spacex/api/device/common.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "spacex/api/device/Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(EthernetNetworkInterface);
GPBObjCClassDeclaration(NetworkInterface);
GPBObjCClassDeclaration(NetworkInterface_RxStats);
GPBObjCClassDeclaration(NetworkInterface_TxStats);
GPBObjCClassDeclaration(PingTarget);
GPBObjCClassDeclaration(SignedData);
GPBObjCClassDeclaration(WifiNetworkInterface);
GPBObjCClassDeclaration(WifiNetworkInterface_InvalidPacketCounts);
GPBObjCClassDeclaration(WifiNetworkInterface_ThermalStatus);

#pragma mark - CommonRoot

@implementation CommonRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - CommonRoot_FileDescriptor

static GPBFileDescriptor *CommonRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"SpaceX.API.Device"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - DeviceInfo

@implementation DeviceInfo

@dynamic id_p;
@dynamic hardwareVersion;
@dynamic softwareVersion;
@dynamic countryCode;
@dynamic utcOffsetS;
@dynamic softwarePartitionsEqual;
@dynamic isDev;
@dynamic bootcount;
@dynamic antiRollbackVersion;

typedef struct DeviceInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t utcOffsetS;
  int32_t bootcount;
  int32_t antiRollbackVersion;
  NSString *id_p;
  NSString *hardwareVersion;
  NSString *softwareVersion;
  NSString *countryCode;
} DeviceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hardwareVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_HardwareVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, hardwareVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "softwareVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_SoftwareVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, softwareVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "countryCode",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_CountryCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, countryCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "utcOffsetS",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_UtcOffsetS,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, utcOffsetS),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "softwarePartitionsEqual",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_SoftwarePartitionsEqual,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isDev",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_IsDev,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "bootcount",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_Bootcount,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, bootcount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "antiRollbackVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_AntiRollbackVersion,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, antiRollbackVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceInfo class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceState

@implementation DeviceState

@dynamic uptimeS;

typedef struct DeviceState__storage_ {
  uint32_t _has_storage_[1];
  uint64_t uptimeS;
} DeviceState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uptimeS",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceState_FieldNumber_UptimeS,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceState__storage_, uptimeS),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceState class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceState__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignedData

@implementation SignedData

@dynamic data_p;
@dynamic signature;

typedef struct SignedData__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
  NSData *signature;
} SignedData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SignedData_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignedData__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = SignedData_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignedData__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignedData class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignedData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNextIdRequest

@implementation GetNextIdRequest


typedef struct GetNextIdRequest__storage_ {
  uint32_t _has_storage_[1];
} GetNextIdRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNextIdRequest class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetNextIdRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNextIdResponse

@implementation GetNextIdResponse

@dynamic id_p;
@dynamic epochId;

typedef struct GetNextIdResponse__storage_ {
  uint32_t _has_storage_[1];
  uint64_t id_p;
  uint64_t epochId;
} GetNextIdResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetNextIdResponse_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetNextIdResponse__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "epochId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetNextIdResponse_FieldNumber_EpochId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetNextIdResponse__storage_, epochId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNextIdResponse class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetNextIdResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PingTarget

@implementation PingTarget

@dynamic service;
@dynamic location;
@dynamic address;

typedef struct PingTarget__storage_ {
  uint32_t _has_storage_[1];
  NSString *service;
  NSString *location;
  NSString *address;
} PingTarget__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "service",
        .dataTypeSpecific.clazz = Nil,
        .number = PingTarget_FieldNumber_Service,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PingTarget__storage_, service),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "location",
        .dataTypeSpecific.clazz = Nil,
        .number = PingTarget_FieldNumber_Location,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PingTarget__storage_, location),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = PingTarget_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PingTarget__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PingTarget class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PingTarget__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PingResult

@implementation PingResult

@dynamic hasTarget, target;
@dynamic dropRate;
@dynamic latencyMs;

typedef struct PingResult__storage_ {
  uint32_t _has_storage_[1];
  float dropRate;
  float latencyMs;
  PingTarget *target;
} PingResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dropRate",
        .dataTypeSpecific.clazz = Nil,
        .number = PingResult_FieldNumber_DropRate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PingResult__storage_, dropRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "latencyMs",
        .dataTypeSpecific.clazz = Nil,
        .number = PingResult_FieldNumber_LatencyMs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PingResult__storage_, latencyMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "target",
        .dataTypeSpecific.clazz = GPBObjCClass(PingTarget),
        .number = PingResult_FieldNumber_Target,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PingResult__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PingResult class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PingResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BondingChallenge

@implementation BondingChallenge

@dynamic dishId;
@dynamic wifiId;
@dynamic nonce;

typedef struct BondingChallenge__storage_ {
  uint32_t _has_storage_[1];
  NSString *dishId;
  NSString *wifiId;
  NSData *nonce;
} BondingChallenge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dishId",
        .dataTypeSpecific.clazz = Nil,
        .number = BondingChallenge_FieldNumber_DishId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BondingChallenge__storage_, dishId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wifiId",
        .dataTypeSpecific.clazz = Nil,
        .number = BondingChallenge_FieldNumber_WifiId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BondingChallenge__storage_, wifiId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.clazz = Nil,
        .number = BondingChallenge_FieldNumber_Nonce,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BondingChallenge__storage_, nonce),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BondingChallenge class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BondingChallenge__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthenticateRequest

@implementation AuthenticateRequest

@dynamic hasChallenge, challenge;

typedef struct AuthenticateRequest__storage_ {
  uint32_t _has_storage_[1];
  SignedData *challenge;
} AuthenticateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "challenge",
        .dataTypeSpecific.clazz = GPBObjCClass(SignedData),
        .number = AuthenticateRequest_FieldNumber_Challenge,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthenticateRequest__storage_, challenge),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthenticateRequest class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthenticateRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChallengeResponse

@implementation ChallengeResponse

@dynamic signature;
@dynamic certificateChain;

typedef struct ChallengeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *signature;
  NSData *certificateChain;
} ChallengeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = ChallengeResponse_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChallengeResponse__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "certificateChain",
        .dataTypeSpecific.clazz = Nil,
        .number = ChallengeResponse_FieldNumber_CertificateChain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChallengeResponse__storage_, certificateChain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChallengeResponse class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChallengeResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkInterface

@implementation NetworkInterface

@dynamic interfaceOneOfCase;
@dynamic name;
@dynamic up;
@dynamic hasRxStats, rxStats;
@dynamic hasTxStats, txStats;
@dynamic ethernet;
@dynamic wifi;

typedef struct NetworkInterface__storage_ {
  uint32_t _has_storage_[2];
  NSString *name;
  NetworkInterface_RxStats *rxStats;
  NetworkInterface_TxStats *txStats;
  EthernetNetworkInterface *ethernet;
  WifiNetworkInterface *wifi;
} NetworkInterface__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkInterface_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkInterface__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rxStats",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkInterface_RxStats),
        .number = NetworkInterface_FieldNumber_RxStats,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NetworkInterface__storage_, rxStats),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txStats",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkInterface_TxStats),
        .number = NetworkInterface_FieldNumber_TxStats,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NetworkInterface__storage_, txStats),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "up",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkInterface_FieldNumber_Up,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ethernet",
        .dataTypeSpecific.clazz = GPBObjCClass(EthernetNetworkInterface),
        .number = NetworkInterface_FieldNumber_Ethernet,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkInterface__storage_, ethernet),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wifi",
        .dataTypeSpecific.clazz = GPBObjCClass(WifiNetworkInterface),
        .number = NetworkInterface_FieldNumber_Wifi,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkInterface__storage_, wifi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkInterface class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkInterface__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "interface",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkInterface_ClearInterfaceOneOfCase(NetworkInterface *message) {
  GPBDescriptor *descriptor = [NetworkInterface descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkInterface_RxStats

@implementation NetworkInterface_RxStats

@dynamic bytes;
@dynamic packets;
@dynamic frameErrors;

typedef struct NetworkInterface_RxStats__storage_ {
  uint32_t _has_storage_[1];
  uint64_t bytes;
  uint64_t packets;
  uint64_t frameErrors;
} NetworkInterface_RxStats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bytes",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkInterface_RxStats_FieldNumber_Bytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkInterface_RxStats__storage_, bytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "packets",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkInterface_RxStats_FieldNumber_Packets,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkInterface_RxStats__storage_, packets),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "frameErrors",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkInterface_RxStats_FieldNumber_FrameErrors,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NetworkInterface_RxStats__storage_, frameErrors),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkInterface_RxStats class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkInterface_RxStats__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkInterface)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkInterface_TxStats

@implementation NetworkInterface_TxStats

@dynamic bytes;
@dynamic packets;

typedef struct NetworkInterface_TxStats__storage_ {
  uint32_t _has_storage_[1];
  uint64_t bytes;
  uint64_t packets;
} NetworkInterface_TxStats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bytes",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkInterface_TxStats_FieldNumber_Bytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkInterface_TxStats__storage_, bytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "packets",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkInterface_TxStats_FieldNumber_Packets,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkInterface_TxStats__storage_, packets),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkInterface_TxStats class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkInterface_TxStats__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkInterface)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthernetNetworkInterface

@implementation EthernetNetworkInterface

@dynamic linkDetected;
@dynamic speedMbps;
@dynamic autonegotiationOn;
@dynamic duplex;

typedef struct EthernetNetworkInterface__storage_ {
  uint32_t _has_storage_[1];
  uint32_t speedMbps;
  EthernetNetworkInterface_Duplex duplex;
} EthernetNetworkInterface__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "linkDetected",
        .dataTypeSpecific.clazz = Nil,
        .number = EthernetNetworkInterface_FieldNumber_LinkDetected,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "speedMbps",
        .dataTypeSpecific.clazz = Nil,
        .number = EthernetNetworkInterface_FieldNumber_SpeedMbps,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthernetNetworkInterface__storage_, speedMbps),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "autonegotiationOn",
        .dataTypeSpecific.clazz = Nil,
        .number = EthernetNetworkInterface_FieldNumber_AutonegotiationOn,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "duplex",
        .dataTypeSpecific.enumDescFunc = EthernetNetworkInterface_Duplex_EnumDescriptor,
        .number = EthernetNetworkInterface_FieldNumber_Duplex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EthernetNetworkInterface__storage_, duplex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EthernetNetworkInterface class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthernetNetworkInterface__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EthernetNetworkInterface_Duplex_RawValue(EthernetNetworkInterface *message) {
  GPBDescriptor *descriptor = [EthernetNetworkInterface descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EthernetNetworkInterface_FieldNumber_Duplex];
  return GPBGetMessageRawEnumField(message, field);
}

void SetEthernetNetworkInterface_Duplex_RawValue(EthernetNetworkInterface *message, int32_t value) {
  GPBDescriptor *descriptor = [EthernetNetworkInterface descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EthernetNetworkInterface_FieldNumber_Duplex];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum EthernetNetworkInterface_Duplex

GPBEnumDescriptor *EthernetNetworkInterface_Duplex_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Half\000Full\000";
    static const int32_t values[] = {
        EthernetNetworkInterface_Duplex_Unknown,
        EthernetNetworkInterface_Duplex_Half,
        EthernetNetworkInterface_Duplex_Full,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EthernetNetworkInterface_Duplex)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EthernetNetworkInterface_Duplex_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EthernetNetworkInterface_Duplex_IsValidValue(int32_t value__) {
  switch (value__) {
    case EthernetNetworkInterface_Duplex_Unknown:
    case EthernetNetworkInterface_Duplex_Half:
    case EthernetNetworkInterface_Duplex_Full:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - WifiNetworkInterface

@implementation WifiNetworkInterface

@dynamic hasThermalStatus, thermalStatus;
@dynamic hasInvalidPacketCounts, invalidPacketCounts;
@dynamic channel;
@dynamic missedBeacons;
@dynamic linkQuality;
@dynamic signalLevel;
@dynamic noiseLevel;

typedef struct WifiNetworkInterface__storage_ {
  uint32_t _has_storage_[1];
  uint32_t channel;
  uint32_t missedBeacons;
  WifiNetworkInterface_ThermalStatus *thermalStatus;
  WifiNetworkInterface_InvalidPacketCounts *invalidPacketCounts;
  double linkQuality;
  double signalLevel;
  double noiseLevel;
} WifiNetworkInterface__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thermalStatus",
        .dataTypeSpecific.clazz = GPBObjCClass(WifiNetworkInterface_ThermalStatus),
        .number = WifiNetworkInterface_FieldNumber_ThermalStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WifiNetworkInterface__storage_, thermalStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "invalidPacketCounts",
        .dataTypeSpecific.clazz = GPBObjCClass(WifiNetworkInterface_InvalidPacketCounts),
        .number = WifiNetworkInterface_FieldNumber_InvalidPacketCounts,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WifiNetworkInterface__storage_, invalidPacketCounts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channel",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_FieldNumber_Channel,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WifiNetworkInterface__storage_, channel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "linkQuality",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_FieldNumber_LinkQuality,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(WifiNetworkInterface__storage_, linkQuality),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "signalLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_FieldNumber_SignalLevel,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(WifiNetworkInterface__storage_, signalLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "noiseLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_FieldNumber_NoiseLevel,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(WifiNetworkInterface__storage_, noiseLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "missedBeacons",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_FieldNumber_MissedBeacons,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WifiNetworkInterface__storage_, missedBeacons),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WifiNetworkInterface class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WifiNetworkInterface__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WifiNetworkInterface_ThermalStatus

@implementation WifiNetworkInterface_ThermalStatus

@dynamic level;
@dynamic temp;
@dynamic temp2;
@dynamic powerReduction;
@dynamic dutyCycle;

typedef struct WifiNetworkInterface_ThermalStatus__storage_ {
  uint32_t _has_storage_[1];
  uint32_t level;
  uint32_t temp;
  uint32_t powerReduction;
  uint32_t dutyCycle;
  double temp2;
} WifiNetworkInterface_ThermalStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_ThermalStatus_FieldNumber_Level,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WifiNetworkInterface_ThermalStatus__storage_, level),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "temp",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_ThermalStatus_FieldNumber_Temp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WifiNetworkInterface_ThermalStatus__storage_, temp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "temp2",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_ThermalStatus_FieldNumber_Temp2,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WifiNetworkInterface_ThermalStatus__storage_, temp2),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "powerReduction",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_ThermalStatus_FieldNumber_PowerReduction,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WifiNetworkInterface_ThermalStatus__storage_, powerReduction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dutyCycle",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_ThermalStatus_FieldNumber_DutyCycle,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(WifiNetworkInterface_ThermalStatus__storage_, dutyCycle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WifiNetworkInterface_ThermalStatus class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WifiNetworkInterface_ThermalStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(WifiNetworkInterface)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WifiNetworkInterface_InvalidPacketCounts

@implementation WifiNetworkInterface_InvalidPacketCounts

@dynamic rxInvalidNwid;
@dynamic rxInvalidCrypt;
@dynamic rxInvalidFrag;
@dynamic txExcessiveRetries;
@dynamic invalidMisc;

typedef struct WifiNetworkInterface_InvalidPacketCounts__storage_ {
  uint32_t _has_storage_[1];
  uint32_t rxInvalidNwid;
  uint32_t rxInvalidCrypt;
  uint32_t rxInvalidFrag;
  uint32_t txExcessiveRetries;
  uint32_t invalidMisc;
} WifiNetworkInterface_InvalidPacketCounts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rxInvalidNwid",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_InvalidPacketCounts_FieldNumber_RxInvalidNwid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WifiNetworkInterface_InvalidPacketCounts__storage_, rxInvalidNwid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rxInvalidCrypt",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_InvalidPacketCounts_FieldNumber_RxInvalidCrypt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WifiNetworkInterface_InvalidPacketCounts__storage_, rxInvalidCrypt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rxInvalidFrag",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_InvalidPacketCounts_FieldNumber_RxInvalidFrag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WifiNetworkInterface_InvalidPacketCounts__storage_, rxInvalidFrag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "txExcessiveRetries",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_InvalidPacketCounts_FieldNumber_TxExcessiveRetries,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WifiNetworkInterface_InvalidPacketCounts__storage_, txExcessiveRetries),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "invalidMisc",
        .dataTypeSpecific.clazz = Nil,
        .number = WifiNetworkInterface_InvalidPacketCounts_FieldNumber_InvalidMisc,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(WifiNetworkInterface_InvalidPacketCounts__storage_, invalidMisc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WifiNetworkInterface_InvalidPacketCounts class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WifiNetworkInterface_InvalidPacketCounts__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(WifiNetworkInterface)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LLAPosition

@implementation LLAPosition

@dynamic lat;
@dynamic lon;
@dynamic alt;

typedef struct LLAPosition__storage_ {
  uint32_t _has_storage_[1];
  double lat;
  double lon;
  double alt;
} LLAPosition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lat",
        .dataTypeSpecific.clazz = Nil,
        .number = LLAPosition_FieldNumber_Lat,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LLAPosition__storage_, lat),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lon",
        .dataTypeSpecific.clazz = Nil,
        .number = LLAPosition_FieldNumber_Lon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LLAPosition__storage_, lon),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "alt",
        .dataTypeSpecific.clazz = Nil,
        .number = LLAPosition_FieldNumber_Alt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LLAPosition__storage_, alt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LLAPosition class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LLAPosition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ECEFPosition

@implementation ECEFPosition

@dynamic x;
@dynamic y;
@dynamic z;

typedef struct ECEFPosition__storage_ {
  uint32_t _has_storage_[1];
  double x;
  double y;
  double z;
} ECEFPosition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.clazz = Nil,
        .number = ECEFPosition_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ECEFPosition__storage_, x),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "y",
        .dataTypeSpecific.clazz = Nil,
        .number = ECEFPosition_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ECEFPosition__storage_, y),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "z",
        .dataTypeSpecific.clazz = Nil,
        .number = ECEFPosition_FieldNumber_Z,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ECEFPosition__storage_, z),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ECEFPosition class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ECEFPosition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
